<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="http://upload-images.jianshu.io/upload_images/1113930-18b8ed878a0adf48.png"/>
	 <link rel="shortcut icon" href="http://upload-images.jianshu.io/upload_images/1113930-18b8ed878a0adf48.png">
	
			
    <title>
    Vinci’s Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>

			    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_solarized.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Vinci LEE</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/PS/">PS</a></li><li><a class="category-link" href="/categories/读书笔记/">读书笔记</a></li><li><a class="category-link" href="/categories/面试准备/">面试准备</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="http://www.jianshu.com/u/0324b067fe23" title="简历">
		                简历
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
		            
		                <li><a href="https://github.com/kafka000" class="icon fa-github"><span class="label">GitHub</span></a></li>
		            
		            
		            
		            
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(http://upload-images.jianshu.io/upload_images/1113930-ff3a4a21627bc73e.png);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >PM学技术之数据处理篇</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <blockquote>
<p>本文是数据篇产品科普总结，温故而知新，产品和开发一样都必须掌握技术。</p>
<p>也许不需要那么深入，但广度是一定要有的。</p>
<p>加粗处供自查使用</p>
</blockquote>
<h2 id="PM学技术之数据处理篇"><a href="#PM学技术之数据处理篇" class="headerlink" title="PM学技术之数据处理篇"></a>PM学技术之数据处理篇</h2><h3 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h3><ul>
<li><strong>关系型数据库</strong>有：MySQL、Oracle、RDBMS  </li>
<li><strong>非关系型数据库</strong>：Redis、MongoDB、HBase  </li>
</ul>
<p>我们平常听到的数据库大多是指<strong>关系型数据库</strong>,用来<strong>增删改查</strong>等。但是关系</p>
<p>型数据库也有不少缺点，比如：  </p>
<ol>
<li>高并发时性能会遇到瓶颈  </li>
<li>扩展性差  </li>
<li>恢复数据慢  </li>
</ol>
<p><strong>关系型数据库</strong>，把 TA 想象成一张<strong> Excel</strong> 表格就可以了哦。TA 有这么个 特点，就像一个人的个人信息一样(姓名、性别、身高、籍贯等)，每个人的 数据都是格式化的，每个人的信息都可以被填入表中。  </p>
<p>如果<strong>有一个人有些特殊信息</strong>，比如有一个人有尾巴，你并不能记录到数 据库当中，因为并没有<strong>「是否有尾巴」</strong>这个字段。  </p>
<p>下面就来介绍下<strong>非关系型数据库</strong>，也常常被成为 NOSQL 数据库，NOSQL 有的人解释为「不需要 SQL」，也有人解释为「Not Only SQL」，<strong>最核心</strong>的一点就是 NOSQL 数据库一般都是 Key-Value 形式的，<strong>它的查询不需要 SQL语句支持</strong>。  </p>
<p>我们举个 KV 数据库的例子:  </p>
<p>在这个数据库当中，像很多系统一样，主键，也就是 Key，为手机号码。 值，也就是 Value 为一个字符串，如果你看过我以前写过的文章，你应该可 以看到 Value 是一段Json 字符串，而且每条记录里面记录的东西都不同 (对于扩展性，相比关系型数据库强到不知哪里去了)，对于不需要的字段数据，绝不冗余。  </p>
<p>查询的时候不用 SQL，怎么查询呢，因为数据库为 <strong>Key-Value</strong> 数据库，所<br>以只能通过 Key 来查询，也就是输入手机号，数据库返回那段 Json 数据。  实整个非关系型数据库的理解非常简单，重要的是 TA 的意义。  </p>
<p>首先，<strong>是效率的提升</strong>，据说 KV 数据库查询效率要高于 SQL 好几倍。   </p>
<p>另外，<strong>好处就是扩展性</strong>，TA 不像关系型数据库一样，存入数据必须按照 格式按照套路存储。如上所述，只要定义了 Key，数据库是不关心 Value 是 什么的，这就使整个数据库不用在束缚于字段的设计。   </p>
<p>最后，<strong>这种数据库是未来的趋势</strong>，而且大多数都免费，并且 Json 数据格 式应该已经成为互联网最流行的数据格式，对 Java 以及 JavaScript 都极友好。  </p>
<p>至于关系型数据库和 NOSQL 数据库之间如何选择，还是要根据 体情况 决策的，但是未来 NOSQL 数据库应该会成为主流，因为我已经看到了好多数 据库改造与升级都开始用 NOSQL 数据库了。</p>
<h3 id="数据恢复原理"><a href="#数据恢复原理" class="headerlink" title="数据恢复原理"></a>数据恢复原理</h3><p>数据丢失的方式主要分两种：</p>
<ol>
<li>存储介质损坏导致的数据丢失,比如硬盘丢了、坏了</li>
<li>数据从存储介质上删除，比如收件格式化了  </li>
</ol>
<p>那么，这些可以恢复数据的情况，是怎么一回事呢?  </p>
<p>大部分文件系统是 这样设计的，<strong>一部分是索引区，另一部分是数据区</strong>。  </p>
<p>当我们新加一个文件 时，先往索引区里添加一条文件索引信息，然后往数据区里<br>写入文件的完整内容。当删除一个文件时，一般只会将它的信息<strong>从索引区里删除</strong>，而<strong>数据区</strong>里的内容却不做删除，只是<strong>标记为无人使用</strong>，如果有新的文件写入系统，那么这些被标记无人使用的区域很有可能<strong>被新文件覆盖掉</strong>。  </p>
<p>所以，当我们手贱误删了一些文件后，想要恢复它们是有可能的，就是 需要保证没有 它的数据进来，将误删的文件数据覆盖掉。所以，如果发现误删文件，那么从那一刻起就要时刻注意不要写入新的文件，否则，你数据 被覆盖后，找谁都帮不了你的忙。数据恢复的软件，比较常用的就是 EasyRecovery，如果有需要，请自行搜索。  </p>
<p>不过，像朴槿惠同学这种，想不顾一切毁灭资料的，那么可以采取简单粗暴的方式，就是给硬盘转上几个洞，或者使 被碾压多次，直到物理损 坏。 次，就是非暴力方式，在删除敏感资料后，可以增加一些大文件，让 它们把不想留着的文件空间都覆盖刷新一次，这样数据区内的文件也没有残留了。  </p>
<h3 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h3><p>小长假归来，发现世界的另一边又搞出了大新闻，整出个「巴拿马文件<br>泄漏事件」，某个律师行泄漏了 2.6TB 的机密信息。  </p>
<p>假设产品经理听到这个消息后，提出这么一个需求:分析这 2.6TB 的数 据，找出 中最热的 10 个人名。这个需求看起来很简单，无非就是先读取 文件，做一下分词处理，找出 中的人名，再累加计数，最后得出计数最多 的人名。可是，这里有 2.6TB 的数据诶，如果处理速度是 1MB/s，那么也得 算个 31.5 天，等到那个时候，也许产品经理已经忘记了这个需求:)  </p>
<p>为了不让产品经理忘记这个需求，那我们得加快处理速度了，一台机器处理不过来，那我们就堆机器吧，上个100 台机器，总能在一天之内搞定吧。<strong>那么面对这 100 台机器，该如何分配任务，以及如何收集处理结果呢? 这程序该怎么写呢?</strong>这就祭出今天要说的 MapReduce 了。  </p>
<p>MapReduce 是由 Google 提出的一个分布式计算模型，简单的说，就是把 大量的数据分解成独立的单元执行(Map)，然后将结果归并在一起 (Reduce)。  </p>
<p>面对上面的需求，<strong>首先需要做的事将任务分解了(Map)</strong>。可以有这样的一个独立的小任务，以单个文件作为一个输入，然后经过分词、人名筛选等处 理后，得到很多 Key-Value 形式的键值对，这里的 Key 就是某个人名(张三)，Value 就是张三在这个文件中出现的次数。这种独立小任务的处理方式，对于 2.6TB 中的文件都是一模一样的，那么我们就把这些文件统统分配到中90 台机器上去单独执行这些小任务就好了。另外10台机器干嘛呢? 它们就负责 Reduce，将计算结果归并起来，当前面 90 台机器处理完一个文 件了，它就将处理结果扔给这 10 台机器。扔结果可不是乱扔掉哦，它有一个原则，相同 Key 的结果都往同一台机器上扔，如下图中画的那样，蓝色的 处理结果，都扔给了第一台机器，这样它就保证了同一个 Key 的数据完整<br>性。</p>
<p>  最终，从全部 Reduce 的机器上，可以获得每个名字在这 2.6TB 数据中出 现的统计结果，将 中次数最多的前 10 个列出来，就得到了我们想要的结 果了。</p>
<p><strong>说到底就是将大量重复独立的任务，分摊到不同的机器上去执行，分担了整体运行的时间。</strong></p>
<p>这样搞了，只要 7 个多小时，产品经理就能拿到他要的数据了。还想更快，那就继续堆机器吧，哈哈~</p>
<h3 id="SQL语句（待补充）"><a href="#SQL语句（待补充）" class="headerlink" title="SQL语句（待补充）"></a>SQL语句（待补充）</h3><p>写程序要学编程语言，操作数据库要学 SQL 语句，SQL 语句有很多，<strong>比如创建数据库，删除数据库，创建表，删除表，修改表等等</strong>，但也许你工作中 <strong>最需要</strong>的是<strong>「查询」</strong>，也就是<strong> SQL 语句中最经典 的 Select</strong>，Select 语句表示 要从表中查询出符合一定条件的所有记录。  </p>
<p>写 SQL 语句有点类似于军训中的队列训练，对程序员来说是基础中的基 础，以前我们曾经讲过天天鼓捣数据，你知道数据库长啥样吗?，相信你知 道「表」是什么样子，假设存在下面一张表，假设表名叫做 Staff，我们来写 写 Select 查询语句。   </p>
<p>上一节说过 Select 语句的作用是查询，也就是在此表中根据条件筛选 出记录，那先设置不用任何条件的语句:  </p>
<p>Select * from Staff   </p>
<p><strong>*表示所有记录，也即翻译为从 Staff 表中挑出所有记录，所以最后结果 为(查询除了所有记录)</strong></p>
<p>下面，我们开始设置条件，比如:<strong>查询所有性别为 female 的记录</strong>，那要<br>用到 where 子句，where 在英文中可以表示条件，你脑中可以翻译为 「当」，SQL 语句如下:  </p>
<p><strong>Select * from Staff Where sex = ‘female’</strong>     </p>
<p><strong>翻译为白话为，选出 Staff 表中所有性别 sex 为 female 的记录</strong></p>
<p>当然，where 就可以加上很多限制条件了，比如:  </p>
<p>Select <em> from Staff <em>*Where sex = ‘female’ AND age &gt; ‘18’ </em></em>那结果显而易见了，只有 3 和 5 两条记录会被筛选出来。</p>
<p>我们刚才做的条件都是指定某一个字段的条件，都是非常肯定的条件， 比如大于 18 或者性别，可不可以做一些<strong>模糊匹配呢</strong>?当然可以  </p>
<p>Select <em> from Staff<em>* Where name like ‘%g’</em></em>   </p>
<p>筛选出来的是 3 和 5，这条语句的意思是 name 这个字段以字母 g 结尾的 记录，这里%是一个<strong>通配符</strong>，<strong>可以通配任何字段</strong>，比如要筛选出中国有多少 人姓「江」，那就可以「江%」来进行通配。  </p>
<p>那可不可以对筛选出来的结果进行排序呢?  </p>
<p>Select * from Staff ORDER BY cup DESC  </p>
<p>是以 cup 字段进行降序排序，ORDER BY 是排序的关键字，DESC 表示降序 排序，如果此处是ASC，则表示是升序排序。也许在这个案例中，升序排序的结果会更好一些  </p>
<p>为啥写的都是 Select <em> 呢，不可以有别的么?必须可以有啊，「</em>」相当 于所有的列都筛选出来，如果选择一个列名或者说字段名，筛选出的记录里 面就只包含这个字段了，例如:  </p>
<p>Select name，age from Staff ORDER BY cup DESC 那结果如下，会仅仅列出名字和年龄:  </p>
<p>下面我们看看 SQL 语句中的函数如何使用，<strong>函数的作用主要用于计算</strong>， 下面的 max 就是计算 age 当中的最大值:  </p>
<p>Select max(age) AS MaxAge from Staff  </p>
<p>上面主要介绍了 Select 语句中的<strong>条件查询，多条件查询，模糊查询，排序，以及 SQL 函数的使用</strong>。  </p>
<p>SQL 语句博大精深，它是和数据库打交道的唯一方法，我只是介绍了最<br>浅显的一小部分。  </p>
<p>如果你要深入的学习 SQL 语言的知识，你应该从两个大的角度挖掘，第 一个是对表的<strong>增删改</strong>，<strong>第二个是查，「查(select)」是变化种类最多，最灵活，也是最核心的，在查询上面可以匹配任意的SQL 函数、条件、排序、运算符、子句、索引、联合查询、别名等等</strong>。  </p>
<p>如果你真的要学习，我劝你还是别买书了，就看看这个网站就好:<br><strong><a href="http://www.w3school.com.cn/sql/" target="_blank" rel="external">http://www.w3school.com.cn/sql/</a></strong></p>
<h3 id="数据库长啥样、数据库索引"><a href="#数据库长啥样、数据库索引" class="headerlink" title="数据库长啥样、数据库索引"></a>数据库长啥样、数据库索引</h3><p><strong>在家里</strong>，找一个东西，经常找了几个小时找不到，最终放弃。<strong>在宜家</strong>，找任何东西，基本都可以靠编号自助搞定。 <strong>是什么导致了这种区别? </strong> </p>
<p>很好理解，宜家的所有东西都在一张表上登记过，然后在这张表里面填 上了物品即将被放置的地址编号，最终这件物品才被工作人员最终放置到 那个地址编号所对应的货架上，便于寻址(计算机中的寻址就是「找」的意 思，不装逼一下，半夜写文章还真有点儿困)。在表上填写若干件物品的名称和相应的地址，有需要的时候再把它找出来，有的时候要进行统计每种物品的库存数量， 实就是一个 型的数据库的应用场景，只不过我举的例子 好像是一个纯人工手工的操作，用脚后跟想想，21世纪的今天，肯定也是由电脑完成的哦。  </p>
<p><strong>数据库的英文叫做 DB(DataBase)</strong>，数据仓库的意思，就是存储数据的 仓库呗，跟宜家存储是真正的物品没有什么不同，一个是在硬盘上，一个是 在真正的三维空间中而已。  </p>
<p>数据库中有多个表(最少要有一张表，空的数据库什么也表示不了哦，表的英文叫 table)，表中真正存储的才是数据记录，一张表简单理解成 excel 的一张二维表格，你就真正理解数据库了，哈哈，如下表所示，表仍 然以行列描述 结构，列 id，name，address 分别描述了物品的编号，名称 以及地址，明眼人应该看清楚了，每一列就是一个物品的一个属性，也就是 这个物品的一个特点。<br>每一行代表了一条记录(record)，这条记录有三个列(特点)。  </p>
<p>这张表格如此清晰，我上面这张图也是从 excel 截取出来的，那为啥不用 excel 直接管理数据啊?<br>主要是因为数据库的存取效率较 excel 更高，<strong>好多系统是没有用户界面的</strong>，你也用不了 excel，最重要的是全世界的数据库 <strong>都支持一种叫做SQL语言的东西来进行「增删改查」操作</strong>，数据库是有事务 系统的(一系列步骤的一步出错了，全部回滚到最初状态)，数据库是支持 命令操作的，而不是简简单单的鼠标操作，这就更减少了人为出错，数据库是支持索引的，数据库的查询效率更高等等等等，后面省略一万条原因。作为一名产品或设计人员，你只需要把数据库简单理解为，数据库是一个大文 件，这个大文件当中有若干个excel表格，每张表格里面存储了若干条记录就。以宜家举例，宜家的后台一定是个大数据库，这个数据库里面至少有两张表，<strong>第一张表记录了所有的员工信息</strong>，包括姓名，年龄，手机，家庭住址，银行卡帐号等等。<strong>第二张表记录了所有商品的信息</strong>，包括商品编号，价格，库存，货架位置等等。  </p>
<p>你的新浪微博的用户名和密码，是存储在<strong>新浪的后台数据库</strong>中的一个表当中的。<br>你的 QQ 号码，也是存储在腾讯的服务器中的某一个数据库里面的。你的 京东购物车的物品列表，也是存储在京东的一个数据库当中的。  </p>
<p><strong>数据库的操作一般有「增」「删」「改」「查」四种操作，都是借助于 SQL 语句完成的</strong>，SQL 读作【se 一声】【kou 一声】，我们写程序的时候，一般用 C 语言，C++或者 Java 等，但是操作数据库的话，全世界的程序员都是统一 的，都是用 SQL 语句来操作数据库，我交你写一句最简单的 SQL 语句，剩下的就靠自学了，哈哈。Select * From table1 where name=「桌子」，这个 SQL 语句的意思是，查询出 table1 这张表中所有名字为「桌子」的记录。  实一个牛逼的程序员可以用一条非常漂亮的 SQL 语句来解决许多复杂问<br>题。 数据库的知识概念很多，我挑几个重要的简单介绍下:  </p>
<ol>
<li><p><strong>索引</strong>，数据库经常有上亿条记录，查询会很慢很慢的，数据库 会提供一个功能，像字一样编制一个」索引「，就是新华字的前几 页一样，靠拼音或偏旁来查询的功能，这个就是索引，这个经常能大幅度提高查询速度。  </p>
</li>
<li><p><strong>事务</strong>，数据库提供了一种机制，就是一件事，必须做完，如果中间出了差错，他会清理掉一切痕迹，回到最初状态，这对于保持数 据的一致性和完整性有功不可没的作用。  </p>
</li>
<li><p><strong>联合查询</strong>，经常一张表格解决不了你的问题，比如有两张表， 一张表是员工基本信息，另一张表是工资表，这个时候，要查询某某 员工的工资，就要两张表一起来「联合查询」    </p>
</li>
<li><p>最后简单介绍下，一个应用程序怎么使用数据库呢?第一步，首先建立和数据库的连接，第二步，利用这个连接，来进行数据库的建表，删表，以及对表的增删改查操作，第三部，关闭数据库连接。最后一步是最容易犯错误的，不关闭数据库连接，经常会产生内存泄漏，以及各种异常。  </p>
</li>
</ol>
<p>说了很多废话， 实数据库的直观表现就可以看成一个 excel 表格。  </p>
<p>现在，我假设你已经被我成功灌输了 「数据库就是一个大文件，里面有 很多表，每个表就像 Excel 一样，存储了若干条记录」这样的概念。但是， 过年回家长辈问你什么是数据库，光这样回答是拿不到红包的，所以我们继 续来深入探讨一下下面几个问题。</p>
<p>什么样的数据适合用数据库来存?  </p>
<p><strong>结构化的数据</strong>。有的数据，天生就有很好的结构，比如要记录一个人，我 们会这样描述:罗玉凤，女，1985 年 9 月生，重庆市綦江区人。要记录一部 电影，这样描述:《星球大战》，导演乔治卢卡斯，科幻片。这样记录数据最 大的好处是方便查询，你要查凤姐的身高，输入「凤姐，身高」两个关键字 就可以了。  </p>
<p><strong>非结构化的数据</strong>，比如苍老师.avi、小苹果.mp3 这些，就不适合 用数据库来存。你拍了一张凤姐的照片准备存起来，先不说能不能放到数据 库里，你要让计算机根据一张图片来得出凤姐身高这样的查询结果，目前的科技水平还是很难做到。<strong>那非结构化的数据怎么存呢</strong>?我上传了一张个人头 像到微信上，微信的服务器就会把这个头像的<strong>图片文件</strong>存到服务器的硬盘 上，然后把<strong>文件路径</strong>存在数据库里。这时候你再去请求这张头像，输入微信 id，头像这样的关键词，微信就会先去数据库查你的头像文件对应的路径， 然后根据路径在硬盘上找到文件回给你。</p>
<p><strong>如何来设计一个数据库</strong>?  </p>
<p>什么?数据库还需要设计?别慌，先来看个例子。你公司的程序员终于忍受不了产品经理无节制的加需求，愤而离职，留下一个朋友圈消息后台需要 你亲自上阵。用户编辑完要发的消息之后，会发送到你这里，你需要把这些 消息完整的存到数据库。每一条消息是这样的:拿到这样的数据之后，你应该如何设计一张数据表的结构呢?前面讲过，表 是由行和列组成的，每一列表示一个属性，每一行表示一条信息。这个跟 Excel 对比起来很容易理解，每一列的属性确定了之后就不变了，以后每来 一条数据，就添加一行。  </p>
<p>这样就可以满足我们的需求了。但是，等数据量大了之后，我们就会发现这个表是有缺陷的。首先是数据冗余，每次李小花同学发表一条消息，就会把他的昵称、性别、姓名重复插入到我们的表中。   </p>
<p>其次，如果在未来的某一天，李小花改了她的昵称，那么我们要遍历整张表去更新她的昵称  (可能现在已经有上亿条消息了)，这也是不现实的。<strong>所以这里需要把表 拆成 user 表和 message 表。</strong>拆表之后，通过姓名李小花既可以查到她的个人信息，又可以查到她发的所有消息。    </p>
<p>这样就可以完美解决上面的两个问题了。<strong>这个过程叫规范化</strong>，就是说数<br>据库的设计是有一些规范的，这些规范经过了严格的数学证明，你一定要遵 守。<br>就差一个码代码的了。   </p>
<p>之前的文章介绍了 SQL 语言，它是专门用来操作数据库的。编程语言你可以理解为是一些命令串起来，每一条命令都可以让系统实现一种功能。上面的两张表，我们这样来创建:  </p>
<p><strong>create_table</strong> user(姓名 varchar(20),昵称 varchar(20),性别 varchar(10)); create_table message(姓名 varchar(20),时间 datetime,message text); 对表本身的操作除了创建，还有 drop(删除)、alter(更改属性)等等。 当有用户新发表了一条消息，我们可以这样插入到表中:  </p>
<p>insert into message values(‘李小花’，now(),’I am very OK!’); 当客户端来了请求，要查询王小龙同学的所有消息的时候，可以这样: select * from message where 姓名=’王小龙’;  </p>
<p>对表内数据的操作还有 delete(删除)、update(更改)等，当然<strong>最精髓</strong>的 还是查询 select 了。我们浏览贴吧看帖子，上微薄看热门都是执行的 select 命令，这个命令的执行速度直接影响到用户的体验，所以程序员必 须优化好。  </p>
<p>数据库这块儿的东西先讲到这里，一些代码大家看不懂没关系，如果以 后用的上，知道是怎么回事儿再去查就能学的很快。但是，即使知识get到了也千万不要去程序员那儿秀技术，程序员都觉得自己技术最牛b，你就让他继续牛 b 下去，对产品经理也没啥坏处，哈哈。</p>
<p>经过前面文章(天天鼓捣数据，你知道数据库长啥样吗?)的科普，相信 各位对数据库应该有一个直观的印象了吧?数据库说白了就是硬盘上的一 个文件，这个文件里面有若干个表，每个表里存了很多条数据。你可以通过一种叫 SQL 的语言，也就是一些命令，来增加、删除、修改和查询这个文件 里存储的数据。  </p>
<p>你以为这样就完事了?程序员可不能这么想。程序员写代码，并不是「能用就好」那么简单。数据库设计的好不好，扩展性怎么样，容错性怎么样， 都很重要。更多的情况是，你精心设计好了数据库的结构，严格遵守了前辈们总结出来的所有规范，放到线上一跑，悲剧了，速度太慢，产品经理查个 数据要等半天，这可怎么是好?   </p>
<p>速度慢要怪就怪硬盘。搞 IT 的应该有个共识，就是离 CPU 越远的存储设 备，速度越慢，先是高速缓存，然后是内存，才是硬盘，还有网络是最慢的。 SSD 还好一点，普通的机械硬盘，只有几十兆的吞吐量，拷一部电影都要几 分钟，拷一堆小文件更是惨不忍睹。扯这么多是想说明什么呢?是说数据库 大多数情况下是在查询数据，查询一次数据，就要读取磁盘上的数据库文 件，而且是非常频繁的读取，速度问题就是这么来的。  </p>
<p>这么说吧，你有一个数据库，存了 10 万个用户的产品日使用时长，从几<br>分钟到几个小时都有。现在，产品经理想查出使用时长最长的那个用户，他 熟练的敲了一行命令(也有可能是熟练的点了某个自动查询的按钮):  </p>
<p>select max(time) from user_table。  </p>
<p>那么，此时计算机在做什么呢?它首先要找到并打开那个有 user_table 表的数据库文件，然后开始一条一条的读取里面的数据:啊，小花，每天使 用 2 个小时，恩，记下来。全蛋，5 分钟，没有小花时间长，扔掉。大宝，10 个小时，哇，把小花扔掉。一直等到读完 10 万条所有的数据，才查到一个 (或多个)最大的结果。此时硬盘已经冒烟了。  </p>
<p>当然，你也可以用上高科技的方法:<strong>数据库索引</strong>，情况会大不相同。数据 库索引是<strong>对数据库里的数据</strong>按照<strong>某个属性</strong>进行<strong>排序</strong>的一种方式。有两个关 键词，某个属性，排序。某个属性是指，索引是跟某个 体的属性挂钩的， 比如上面例子里的「用户使用时长」。排序的意思是，尽管你往数据库里插 入数据的时候是随便插入的，但是索引会保持「用户使用时长」从小到大或 从大的顺序。有了这个顺序，查询就可以用二分法，不用一个一个比对，快多了。  </p>
<p>二分法是啥意思?你有没有玩过猜数字的游戏，别人想一个数字，让你 猜，猜的时候他说大了还是小了，怎么猜最快?很简单，先猜一个小的，再 猜一个大的，然后取中点，再取中点，每次取中点，直到猜中，是最快的。同 理，一堆排好序的数字里面找一个数字，比如下面 7 个数字里面找9，每次都找中间的，依次经过 8、12、9，不用比对 7 次，3 次就找到了。 <strong>这就是二分查找</strong>。  </p>
<p><strong>上面的例子，如果用索引，应该是这样的。</strong>首先对「用户使用时长 」这<br>个属性创建一个索引，一开始是空的，什么都没有。你每次插入一条数据， 比如大雄，使用时长 37 分钟，就把 37 分钟这个数值放到索引里，并使索引 里的所有数值保持从小到大的顺序。经过一段时间，数据库里有了 10 万条 数据，索引里也有了很多排好序的「用户使用时长」。每个时长，还会额外 记录它在原来数据库里的对应的位置。为什么?后面解释。  </p>
<p>现在你来查询使用时长最长的用户，<strong>很简单，找索引的最大值就好了</strong>， 这个应该是一下子就出来的事情，因为它本来就是从小到大的。或者说你想 找「使用半小时」的用户，输入 30 分钟，在索引里利用前面讲的「二分法」，几下就找到了 30 分钟这个值，然后呢，根据这个值额外记录的「在数 据库中对应位置」的信息，就能顺藤摸瓜从数据库里找到这个用户啦。  </p>
<p>以前需要一个一个从硬盘上读取出来比对的，现在排序加二分法，省了很多时间。但是问题也很明显，你应该想到了。创建数据库索引，需要一个 额外的磁盘空间，来存放索引。这个也是不小的开支。虽然索引的每一项， 只是记录了它的值大小，以及它在原来数据库里的位置，现在数据库都是几 千万条数据，开销也不小。  </p>
<p>鱼还是熊掌，这就看你怎么衡量了。如果你的数据库，装在一个硬盘空间很大，但是硬盘速度很慢的电脑上，当然可以用索引，空间换取时间，这 也是大多数索引的应用场景。如果你的硬盘快满了，或者说查数据的产品经 理脾气特别好，等多久都无所谓，那你不用开索引了，随便编个什么「电脑 中病毒了，就是卡」之类的故事，搪塞过去就行。  </p>
<p>这么说来，程序员跟你说中病毒了，很有可能是他不想给你做优化编出 来的呢，一定要警惕啊。  </p>
<p>一句话结尾，数据库索引，对数据库里的某个属性的所有值进行排序， 从而加快查询速度，是一种 型的空间换时间的思想，请君细细品味。   </p>
<p>关于数据库的索引，之前在果果的老文章《天天捣鼓数据库，知道什么 是索引吗?》已经做过介绍，简单来说索引就是对数据数据按照一定的规则 「排序」，加速数据库查询操作。然而这个看似简单的名词， 实里面的水 还挺深。今天来讲讲数据库中索引的分类:<strong>「聚簇索引」和「非聚簇索引」</strong>。 </p>
<p><strong>聚簇索引</strong>  </p>
<p>聚簇索引又叫聚集索引，这种索引的特点是<strong>「按照数据的物理存储顺序 建立索引」</strong>。 体是啥意思呢?看果果给你举个栗子就明白了。  </p>
<p>果果老师有一个 student 数据库表，表中存储着学生的学号(id)和姓名 (name)，表的内容如下:  </p>
<p>现在，果果需要从数据库中查出学号为 8 的学生的姓名，数据库查询语 句如下:  </p>
<p>select name from student where id=8;  </p>
<p>由于数据库中的数据排序没有规律，程序只好逐条查询，直到在最后一 行命中了 id 为 5 的条件才会停止并返回结果。很显然，这种<strong>逐条检索的方 式是十分低效的</strong>。  </p>
<p>为了优化查询性能，果果将 student 表按「id」列建立聚簇索引，建立索<br>引后，表的内容如下:<br>通过对比可以发现，建立索引前和建立索引后，表内存储的数据没有发 生变化，但是建立聚簇索引后的表，数据是按照 id 的大小有序排列的。这 样，后面再查询某个 id 对应的 name 时，就可以利用「二分查找」来快速检 索了。<br>建立聚簇索引会改变数据库表的存储结构和数据排序，所以一张表只能 建立一个聚簇索引。  </p>
<p><strong>非聚簇索引</strong>    </p>
<p>由于聚簇索引的局限性，在实际的数据库使用过程中，为了优化查询性 能，会建立一些非聚簇索引。  </p>
<p>还是拿 student 表举例，上次果果的需求是通过 id 查询 name，但这次 果果想确认下学生 Shawn 的学号，查询语句如下:  </p>
<p>select id from student where name=’Shawn’;  </p>
<p>虽然之前果果对 student表建立过索引(id 列的聚簇索引)，但由于 name 列的排序还是无规律的，因此，要提升查询效率，还需要对 name 列建 立索引。但聚簇索引只能建立一次，我们只能对 student表的name列建立非聚簇索引。  </p>
<p>建立<strong>非聚簇索引</strong>后，表的内容和索引如下:  </p>
<p>很明显，与聚簇索引不同，<strong>非聚簇索引并没有改变表的存储结构和数据排序，而是另外开辟了一块存储区域保存索引</strong>。  </p>
<p>索引中的关键字(name)是有序排列的，进而可以提供高效的查询。同 时，索引中的每一行都有一个指向数据表中 体数据的指针，通过索引查找 的结果可以快速的定位到 体的数据。  </p>
<p>一张数据库表可以建立多个非聚簇索引，这样可以针对不同的查询需求 对不同的列分别建立索引，但每个索引都会额外的消耗大量的存储空间。  </p>
<p>总而言之，对比两种索引类型，聚簇索引在保证了查询效率的同时，不 会额外占用大量的存储空间，但一个表只能建立一个聚簇索引。如果数据表的查询需求多样化，则需要消耗一定的磁盘空间建立非聚簇索引，也就是计 算机科学中常说的用空间换时间。</p>
<h3 id="ORM数据库"><a href="#ORM数据库" class="headerlink" title="ORM数据库"></a>ORM数据库</h3><p>产品经理给我的印象，就是天天在捣鼓数据。什么<strong>日活、留存、转化</strong>，各 种报表眼花缭乱。什么<strong>特征、画像、渠道</strong>，各种分析信手拈来。 实你看到的这些东西，都离不开数据库的支持。<strong>程序员先把原始数据通过埋点上报等手段收集起来，存到数据库里。当你想看某个数据的时候，程序会先把原始数据读出来，经过加工分析，自动生成相应的报表，展示出来</strong>。  </p>
<p>这个过程非常简单，总结起来无非就是一<strong>个数据的存储和读取的过程</strong>， 本身并没有什么可以讨论的新东西。我们前面已经花几篇文章介绍过数据 库的一些简单概念(天天鼓捣数据，你知道数据库长啥样吗?天天捣鼓数据 库，知道什么是索引吗?)，知道数据库实就是一个存放数据的文件，程 序员用一种叫 SQL 的语言，往这个文件里添加、删除、修改和读取数据。SQL语句我们也介绍过一些，它有点像用英语造句，非常接近我们说话的语气，反而不像是一门正儿八经的编程语言。例如:</p>
<p>   SELECT LastName,FirstName FROM Persons  </p>
<p>问题就出在这儿。现在程序员写的代码，是用非常正经的面向对象语言写的，程序里的一切都是对象(五分钟理解什么是面向对象)。现在有一些 数据，是以对象的形式在内存里存储的，现在需要把他们弄到数据库里，怎么办呢?<br>举个例子，有一个对象叫 News，是一条新闻，它有几个属性，比如标题， 正文，作者，时间等等。 </p>
<p>class News<br>{<br>String title;<br>String content;<br>String author;<br>Date time;<br>}    </p>
<p>同时，程序员为了把它存到数据库里，就在数据库中建了一个表也叫 News，表里有几个字段，正好对应 News 的属性:<br>那么如何把这个 News 对象，插入到数据库里的 News 表中呢?  </p>
<p>程序上是这样做的。我们在程序里构造操作数据库的时候，会把 News 对 象的所有属性，挨个读出来，拼接到 SQL 语句中。最后发送给数据库的 SQL 语句，就带上了 News 对象的所有信息。同理，读取数据的时候，一开始我们 从数据库里读到的是一些零散的 News 属性，经过拼装，会重新生成一个 News 对象。  </p>
<p>跟堆积木是一个道理。你堆起一个变形金刚，这就是一个对象，一块一 块的积木它的所有属性。当你在面向对象的程序里使用它的时候，它就是以 对象的形态存在的。当你需要存到数据库里的时候，就把它们拆开，以零散的积木的形式存起来。下次拿出来的时候，再拼装成对象。   </p>
<p><strong>从对象变成 SQL 语句，或者从 SQL 语句变成对象，有一个专业的名词叫 ORM，意思是对象关系映射</strong>。往往这个过程，又臭又长，是一些没有任何乐趣 的类似 a=b 之类的代码，所以大家一般都去找现成的轮子(库)拿来用。这 些轮子很厉害，你塞给它一个对象，告诉它要执行的操作，是增删还是改 查，它就能把相应的 SQL 语句构造出来并发送给数据库执行，全自动的。  </p>
<p>这 实也是写代码的一个套路。一开始大家想把对象存到数据库里，就 自己一条一条的构造 SQL 语句，一条一条的操作数据库。后来有人发现这个 过程是通用的，就抽象出来，做成一个ORM 库。  </p>
<p>以后谁在想做把对象存数据库的事情，只需要调用现成的 API 就行了，<br>根本不用重复发明轮子。  </p>
<p>别的不说，Java 里面最有名的一个 ORM 当属 Hibernate 了，它的设计目 标就是让程序员可以完全用面向对象的思维来操作数据库。当年 Java 后台 正火的时候，程序员速成班里都在教用 SSH 搭建一个网站， 中的 H，就是 指 Hibernate，可见 ORM 对程序员多重要。  </p>
<p>但是数据库里的东西，要比对象复杂太多，它有各种关系，有各种约束。 所以 ORM 并不能适应所有的情况，遇到一些复杂的 SQL，就只能眼睁睁看着 了。所以说不要以为有了 ORM，程序员就只需要专心做好对象这一层面的东 西就行，SQL 作为基本功，出了问题调试起来也方便。  </p>
<p>总结一下。ORM 说白了就是让你能直接把对象存到数据库，也能直接从 数据库读对象。中间它做了一些与 SQL 语言的适配处理，但已经被隐藏和封 装起来了，外面不可见。程序员有了 ORM，只需要关心对象的东西，跟数据 库对接的部分，它会自动帮你处理好。  </p>
<p>你看，站在别人的肩膀上，当个程序员其实挺简单的。  </p>
<h3 id="数据报表的产生过程"><a href="#数据报表的产生过程" class="headerlink" title="数据报表的产生过程"></a>数据报表的产生过程</h3><p>我们平时看到的报表复杂而多样，能够通过多种纬度的数据评估用户的使用习惯和对应功能的价值。然而这些报表是如何产生的呢?今天咱们就看看上报数据一步一步变成报表的大致流程。  </p>
<p>所有上报的数据都是为了记录一次事件的发生或者描述一个状态，上报数据可以设计为 KEY-VALUE 的形式或者数据组合的形式。KEY-VALUE 的形式主要用来统计简单的计数类上报，如按钮点击的次数，某个选项的值 等，KEY 用来区分不同的事件，VALUE 代表事件发生的次数、状态值等;数据 组合的主要用来描述一个事件或者状态需要多种属性描述的场景，比如下载成功事件，描述这个事件的数据组合可能包括对应的下载地址、下载渠道来源、下载耗时等信息。<br>当<strong>上报数据设计</strong>好后，后续的工作才能正常开展。下面一步一步说。  </p>
<p>1、 埋点  </p>
<p>所谓「埋点」，就是在正常的功能逻辑中添加统计逻辑。拿统计微信右上 角「+」的点击次数为例，上报的数据可以采用 KEY-VALUE 形式，我们定义 KEY 为「CLICK_ADD_BTN」，VALUE 的值为点击的次数。当用户点击「+」时， 展示菜单的代码会通过按钮的「回调」(详见《聊聊同步、异 步 和 回 调》)来触发执行，程序猿在业务代码执行完后， 又 加 上 了 统 计 代 码 ， 把「CLICK_ADD_BTN」对应的 VALUE 加 1， 「+」被统计到了一次使用。  </p>
<p>2、 上报<br>并不是每统计到一次事件或者状态就会发起数据上报，客户端统计到的 数据会先暂时存储在内存或者磁盘上，当用户启动、退出应用程序的时候， 或者在 他更合适的时机，将当前周期统计到的事件批量上报到服务器，这 样做的目的主要是考虑到与服务器多次建立连接的性能损耗(详见《不得不 知的 TCP 和 UDP》)和流量问题(相同大小的数据分多次发送比一次发送要 消耗更多流量)，另外客户端在上报 体的统计事件之外，还会将标识用户 的 ID 一并上报，后续用于计算用户相关的数据如日使用用户和留存率等。  </p>
<p>3、 后台记录日志  </p>
<p>数据上报到服务器后，服务器会将客户端上报的原始数据存储到服务器 的磁盘中。一般来说，非强实时性的数据上报到服务器后，并不会立即参与 计算，获得最终的统计结果，比如一个功能的日使用次数，日用户数，日留 存等数据，而是等到服务器负载较低的时间段利用预先配置的计划任务进 行离线处理。这样处理的目的是为了节约服务器资源(钱)，因为大家肯定 不想因为计算统计数据而影响实时业务的处理效率。  </p>
<p>4、 计算&amp;入库  </p>
<p>报表中展示的数据，并不是客户端上报的原始数据，比如「+」的使用次<br>数、使用用户数、日留存率这三组数据，都是通过对客户端上报的 「CLICK_ADD_BTN」对应 VALUE 值的累加并结合上报用户 ID 二次计算得出 的。   </p>
<p>如果我们的产品达到微信这种日登陆数五六亿，那么每天上报的统计数 据将是海量的，为了从这种海量的数据中计算出「+」的使用次数、使用用户 数等信息，就需要用到「数据仓库工 」，比如当下流行的 Hive 处理工 ， 它基于 Hadoop 分布式系统基础框架，利用计算机集群的能力进行分布式计 算。当「数据仓库工 」计算出最终的结果后，计划任务会将结果(「+」的 日使用次数、日使用用户数等数据)保存到数据库中，也就是「入库」过程。 「入库」后的数据才能与前端对接，组成报表展示系统。   </p>
<p>一般情况下，原始数据经过数据仓库工 处理后，对应的日志文件还会 在服务器上保留一段时间(一般 3~7 天)，以便追溯统计问题，所以，如果 发现统计数据有问题问题，一定要及时反馈给负责的程序猿，否则就会 「死」无对证咯。</p>
<p>5、 展示  </p>
<p>当数据「入库」后，报表的展示就水到渠成了。报表系统通过前端页面用 户的输入获取查询条件，然后通过后台数据库查询获得结果，在前端展示出来，这里只是简述了埋点数据上报、统计的大致流程，每个过程中还有很多细节要解决，如后台日志乱码问题、客户端异常导致数据丢失等。一旦数据出现问题，经常需要联系各方人员定位原因。在此呼吁广大的产品大虾一定 要关心、爱护为你做统计需求的程序猿，他们上辈子都是偷了蟠桃的孙悟空。   </p>
<p>对咯，今天别忘了看报表哦。</p>
<h3 id="数据埋点"><a href="#数据埋点" class="headerlink" title="数据埋点"></a>数据埋点</h3><p>上个月咱们了解到埋点数据从上报到生成报表大体分为五个关键环节<br>(复习传送门):<strong>埋点-&gt;上报-&gt;后台记录日志-&gt;计算&amp;入库-&gt;展示</strong>   </p>
<p>今天咱们介绍下统计数据出问题后，一般的原因有哪些，应该如何跟<br>进。  </p>
<p>报表数据为 0<br>一天，韩梅梅找到李雷<br>韩梅梅:『老李啊，咱们这个版本新加的埋点怎么报表上都是 0 啊?』李 雷(惊讶的):『啊?我看看!』<br>老李为啥会『惊讶』呢，因为这个数据的上报在版本上线前已经测试通 过了。不过，为了保持程序猿做事的严谨性，老李还是通过『抓包』或者『查 日志』的手段确认了客户端功能无误，然后果断的找到负责后台数据统计的 同学，将问题抛给了他们。<br>小编点评:数据有上报而报表数据为 0，这种问题一般会出现在『计算&amp; 入库』和『展示』环节。因为『上报』和『后台录入日志』这两个过程是与  体的埋点功能无关的，它们对应的逻辑和功能相对稳定。而『计算&amp;入库』和 『展示』环节则多需要根据不同的统计需求做修改，所以在验证客户端埋点 功能正常后，最有可能出问题的就是这两处。如果出现这种异常，向韩梅梅 一样，先找到李雷确认功能正常后，再联系后台负责数据统计的同学跟进， 一般情况下，异常的数据都是可以恢复的。如果不幸确实由于客户端的 Bug 导致数据没有上报，那数据就只能等下个版本修复了。(韩梅梅:   </p>
<p>『胡说，不是还有热补丁吗?』好吧，产品会技术，谁也挡不住，小弟佩服!)   </p>
<p><strong>报表数据大面积突降</strong>  </p>
<p>韩梅梅:『老李啊，怎么今天咱们的日使用、在线时长、点击量…(此处 省略一万个数据名词)都比平时少了一半?』  </p>
<p>李雷(胸有成竹地):『我找人帮你看看!』  </p>
<p>老李从运维同学处了解到，昨天对服务器上的日志进行了迁移，由于迁 移数据迁移过程太长导致一些日志没有参与『计算&amp;入库』，等下会重新部 署昨天的统计任务，恢复数据。  </p>
<p>小编点评:  </p>
<p>如果已经稳定很久的报表，突然出现大范围的数据突降，先找找运维同 学吧，看看最近日志分析系统有做策略调整或者日志迁移，导致报表中只收 录了部分日志的数据。如果是的话，不用担心，即便你不找上门，运维同学 也会主动跟进，把数据恢复的。  </p>
<p><strong>报表数据突增</strong>   </p>
<p> 韩梅梅:『老李啊，这两天咱们没做什么推广，怎么天天乱跑的下载量突然上涨了好几倍?是不是你又出 Bug 了?』   </p>
<p>李雷(无辜地):『怎么可能!』   </p>
<p>老李当然无辜了，心中一万匹草泥马:『产品没做推广，我们程序猿也改不了线上版本的代码啊，前几天还正常运行的统计逻辑，突然到某一天错乱了，你以为我写的是『千年虫』啊』。    </p>
<p>小编点评:  </p>
<p>线上的单个数据或者相关的几个数据突然出现异常增长，很有可能是被人恶意刷量。要确定这种问题，直接找数据组的同学查下原始日志，确认下是不是有个别 IP 或者用户 ID 对应的 PV 数量明显异常。如果这样都查不出来异常原因，恭喜，你提前完成了 KPI!  </p>
<p><strong>历史数据出现问题</strong> </p>
<p>韩梅梅:『老李啊，今天做数据对比的时候，发现去年 3 月份的曝光量 数据好像不大对，你快帮我看看啥原因?』  </p>
<p>李雷:…  实老李想说『你把我小时候弄丢的奶嘴找回来，我就帮你找曝光量<br>不对的原因!』 小编点评:  </p>
<p>要确认问题的原因，上报数据的原始日志是十分重要的线索。报表中的 数据，可以追溯到几年前，但是原始日志由于数据量太大，可能只会在服务 器存储几个月甚至几天。所以，对于这种要求，程序猿只能说『臣妾做不到 啊!』。  </p>
<p><strong>报表数据明显低于预期</strong><br>韩梅梅:『Lucy，昨天咱们的新版本访问这个页面的只有 6 人，看来咱们高估了用户的需求。』  </p>
<p>Lucy:『是啊，太出乎意料了，我预计至少应该有 3000 人访问呢。』 李雷听到了韩梅梅和 Lucy 的对话，默默的在开发中的版本上修复了这个关键路径数据漏报的 Bug。 小编点评:  </p>
<p>这种问题找负责埋点同学准没错，肯定是遗漏了重要的用户路径，重新埋点吧。<br>业务流复杂的漏斗统计数据异常。  </p>
<p>给产品经理讲技术 在一个韩梅梅刚刚建立的群中  </p>
<p>韩梅梅:『@all 昨天投放的天天乱跑推广 Banner 只带来了 5 个新增， 请大家帮忙看下原因!』  </p>
<p>群里的一百多号人认真的读完了韩梅梅发来的消息后，就各自继续忙自己之前的工作去了。  </p>

            </div>

           
        
</body>



 	
</html>
